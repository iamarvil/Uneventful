using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace Uneventful.CodeGenerator;

[Generator]
public class EventStoreBuilderExtensionCodeGenerator : ISourceGenerator {
    public void Initialize(GeneratorInitializationContext context) {

    }

    public void Execute(GeneratorExecutionContext context) {
        var syntaxTrees = context.Compilation.SyntaxTrees;

        var assemblyName = context.Compilation.AssemblyName;
        var name = assemblyName?.Replace(".", "");
        var eventTypes = new List<string>();
        var namespaces = new HashSet<string>();

        foreach (var syntaxTree in syntaxTrees) {
            var root = syntaxTree.GetRoot();
            var records = root
                .DescendantNodes()
                .OfType<RecordDeclarationSyntax>()
                .Where(record => record.BaseList != null &&
                                 record.BaseList.Types.Any(type => type.ToString() == "EventBase"));

            foreach (var record in records) {
                var recordName = record.Identifier.Text;
                var parent = record.Identifier.Parent?.Parent;

                if (parent is ClassDeclarationSyntax syntax) {
                    var className = syntax.Identifier.Text;
                    eventTypes.Add($"{className}.{recordName}");
                    AddNamespace(namespaces, syntax);
                }
                else {
                    eventTypes.Add($"{recordName}");
                    if (parent != null) {
                        AddNamespace(namespaces, parent);
                    }
                }
            }
        }

        if (eventTypes.Count == 0) return;

        var namespaceData = string.Join("\r\n", namespaces.Select(ns => $"using {ns};"));

        if (assemblyName != null && name != null) {
            context.AddSource("EventStoreBuilderExtensions.g.cs",
                BuildEventStoreBuilderExtensions(assemblyName, eventTypes, namespaceData, name));
            
            context.AddSource($"EventTypeRegistry.g.cs", BuildEventwrapperConverterEventTypeRegistration(assemblyName, eventTypes, namespaceData));
        }
    }

    private static string BuildEventwrapperConverterEventTypeRegistration(string assemblyName,
        IEnumerable<string> eventTypes, string namespaceData) {
        var source = $$"""
                          // <auto-generated />
                          using System;
                          using Uneventful.EventStore;
                          using Uneventful.EventStore.Serialization;
                          {{namespaceData}}
                          
                          namespace {{assemblyName}};
                          
                          public static class EventTypeRegistry {
                              public static readonly HashSet<Type> Events = [
                                {{string.Join($", {Environment.NewLine}", eventTypes.Select(eventType => $"\t\ttypeof({eventType})"))}}
                              ];
                          }
                       """;

        return source;

    }

    private static string BuildEventStoreBuilderExtensions(string assemblyName, IEnumerable<string> eventTypes, string namespaceData,
        string name) {
        var source = $$"""
                       // <auto-generated />
                       using System;
                       using Uneventful.EventStore;
                       {{namespaceData}}

                       namespace {{assemblyName}};

                       public static class EventStoreBuilderExtensions {
                           public static EventStoreBuilder Register{{name}}Events(this EventStoreBuilder builder) {
                       {{string.Join(Environment.NewLine, eventTypes.Select(eventType => $"\t\tbuilder.RegisterEvent<{eventType}>();"))}}
                       
                               return builder;
                           }
                       } 
                       """;
        
        return source;
    }

    private static void AddNamespace(HashSet<string> namespaces, SyntaxNode parent)
    {
        if (parent is FileScopedNamespaceDeclarationSyntax fsns) {
            namespaces.Add(fsns.Name.ToString());
        } else if (parent is NamespaceDeclarationSyntax ns) {
            namespaces.Add(ns.Name.ToString());
        } else if (parent?.Ancestors().FirstOrDefault(x => x is FileScopedNamespaceDeclarationSyntax or NamespaceDeclarationSyntax) is { } ancestor) {
            if (ancestor is FileScopedNamespaceDeclarationSyntax fileScopedNs) {
                namespaces.Add(fileScopedNs.Name.ToString());
            } else if (ancestor is NamespaceDeclarationSyntax nestedNs) {
                namespaces.Add(nestedNs.Name.ToString());
            }
        }
    }
}